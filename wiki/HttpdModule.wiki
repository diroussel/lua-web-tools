#summary HTTPD module API

= Introduction =

This page describes the functions provided by the HTTPD Module.

= Import =

{{{
require "httpd"
}}}

= Functions =

== `httpd.pairs (apr_table)` ==

Returns three values so that the construction

{{{
for key, value in httpd.pairs(t) do body end
}}}

will iterate over all key-value pairs in the passed APR table. This function is used with the header tables of the `request` value and the `args` value.

== `httpd.set_content_type (content_type)` ==

Sets the response content type to `content_type`.

== `httpd.add_cookie (name [, value [, expires [, path [, domain [, secure [, httponly]]]]]])` ==

Adds a cookie `name`. `value` is a string representing the value of the cookie; if `value` is absent, the value of the cookie is the empty string. `expires` is a number representing the expiry of the cookie as a Unix timestamp; if `expires` is absent or negative, the cookie is valid for the session only. `path` and `domain` are string values representing the path and domain of the cookie respectively; if they are absent, the cookie is added without an explicit path or domain. If `secure` and `httponly` are `true` when evaluated as boolean values, they indicate that the cookie must only be transmitted on secure connections and that the cookie is unavailable to client-side scripting respectively, otherwise the cookie is added without these security restrictions.

== `httpd.write_template (filename [, flags])` ==

Writes a template from a file referenced by `filename`. `flags` is a string with each character modifying the processing of the template as follows: 

  * `p`: parse the template; if absent, the template is written as is
  * `x`: escape XML reserved characters in substitutions
  * `u`: escape URL reserved characters in substitutions
  * `n`: substitute an empty string for `nil` expressions
  * `e`: substitute an empty string for expressions with a runtime error

If `flags` is absent, it defaults to `px`.

If a template is parsed, the following instructions are processed by the template engine:

|| *Instruction* || *Description* ||
|| `<l:if cond="cond_0"> template_0 <l:elseif cond="cond_1" /> template_1 ... <l:elseif cond="cond_n" /> template_n <l:else /> template_else </l:if>` || Evaluates `cond_0` and processes `template_0` if true, otherwise continues to evaluate `cond_1` to `cond_n` processing one of `template_1` to `template_n` if the respective condition is true, otherwise processes `template_else`. The use of the `l:elseif` and `l:else` elements is optional. ||
|| `<l:for names="name_1, name_2, ... , name_n" in="iterator_exp"> template </l:for>` || Equivalent to the construction `for name_1, name_2, ..., name_n in iterator_exp do p(template) end` where `p(template)` represents the processing of `template`. ||
|| `<l:set names="name_1, name_2, ..., name_n" exps="exp_1, exp_2, ..., exp_n" />` || Equivalent to the construction `name_1, name_2, ..., name_n = exp_1, exp_2, ..., exp_n`. || 
|| `<l:include filename="filename_exp" flags="flags" />` || Processes the template from the file referenced by `filename_exp`. `flags` are optional and have the same meaning and default as in `httpd.write_template`. ||
|| `${exp}` || If `exp` yields a string or number value, substitutes its string representation; otherwise substitues `(type)`. Substitutions are processed following the current flags. ||
|| `$[flags]{exp}` || Equivalent to `${exp}` with `flags` used instead of the current flags. ||

== `httpd.escape_xml (string)` ==

Escapes XML reserved characters in a string and returns the escaped string. More specifically, the following characters are escaped:

|| *Character* || *Escape* ||
|| & || &quot; ||
|| `"` || `&quot;` ||
|| `<` || `&lt;` ||
|| `>` || `&gt;` ||

== `httpd.escape_url (string)` == 

Escapes URL reserved characters in a string and returns the escaped string. More specifically, alphanumeric characters, `-`, `.`, `_`, and `~` are considered unreserved characters, and all other characters are considered reserved characters according to RFC 3986. Reserved characters are escaped by a percent sign followed by two hexadecimal (uppercase) digits representing the value of the escaped character.

== `httpd.input` ==

A file descriptor for reading from the HTTP request body. The file descriptor behaves like a regular Lua file descriptor.

== `httpd.output` ==

A file descriptor for writing to the HTTP response body. The file descriptor behaves like a regular Lua file descriptor.

== `httpd.read (...)` ==

Equivalent to `httpd.input:read(...)`.

== `httpd.write (...)` ==

Equivalent to `httpd.output:write(...)`.

== `httpd.redirect (request, uri, status)` ==

Sets a  `Location` header with a value of `http://{request.hostname}{uri}` and returns `status`. The idiom for using this function is

{{{
return httpd.redirect(request, "/next.lua", status)
}}}

where `status` is an appropriate 3xx status code.

== `httpd.dump (value)` ==

Writes `value` to the HTTP response body formatted in HTML. The function handles both tables and recursion.

== `httpd.match (path, ...)` ==

Matches `path` against the patterns following it and returns the captured values of the first matching pattern with numbers from empty captures replaced by `nil`. The ididom for using this function is

{{{
a, b, c = httpd.match(request.path_info,
        "^/(%w+)/(%w+)/(%d+)$",
        "^/(%w+)/(%w+)$",
        "^/()(%w+)$")
}}}

where the return values are parameters extracted from the request URI using the supplied templates.